(* This file is generated by Why3's Coq driver *)
(* Beware! Only edit allowed sections below    *)
Require Import BuiltIn.
Require BuiltIn.
Require HighOrd.
Require int.Int.
Require int.Abs.
Require int.ComputerDivision.

(* Why3 assumption *)
Inductive ref (a:Type) :=
  | ref'mk : a -> ref a.
Axiom ref_WhyType : forall (a:Type) {a_WT:WhyType a}, WhyType (ref a).
Existing Instance ref_WhyType.
Arguments ref'mk {a}.

(* Why3 assumption *)
Definition contents {a:Type} {a_WT:WhyType a} (v:ref a) : a :=
  match v with
  | ref'mk x => x
  end.

Axiom uint64 : Type.
Parameter uint64_WhyType : WhyType uint64.
Existing Instance uint64_WhyType.

Parameter uint64'int: uint64 -> Numbers.BinNums.Z.

Axiom uint64'axiom :
  forall (i:uint64),
  (0%Z <= (uint64'int i))%Z /\ ((uint64'int i) <= 18446744073709551615%Z)%Z.

(* Why3 assumption *)
Definition uint64'eq (a:uint64) (b:uint64) : Prop :=
  ((uint64'int a) = (uint64'int b)).

Axiom uint64'inj : forall (a:uint64) (b:uint64), uint64'eq a b -> (a = b).

(* Why3 assumption *)
Definition in_bounds (n:Numbers.BinNums.Z) : Prop :=
  (0%Z <= n)%Z /\ (n <= 18446744073709551615%Z)%Z.

Axiom to_int_in_bounds : forall (n:uint64), in_bounds (uint64'int n).

Axiom extensionality :
  forall (x:uint64) (y:uint64), ((uint64'int x) = (uint64'int y)) -> (x = y).

Parameter zero_unsigned: uint64.

Axiom zero_unsigned_is_zero : ((uint64'int zero_unsigned) = 0%Z).

(* Why3 assumption *)
Definition usize := uint64.

Axiom seq : forall (a:Type), Type.
Parameter seq_WhyType : forall (a:Type) {a_WT:WhyType a}, WhyType (seq a).
Existing Instance seq_WhyType.

Parameter length:
  forall {a:Type} {a_WT:WhyType a}, seq a -> Numbers.BinNums.Z.

Axiom length_nonnegative :
  forall {a:Type} {a_WT:WhyType a}, forall (s:seq a), (0%Z <= (length s))%Z.

Parameter get:
  forall {a:Type} {a_WT:WhyType a}, seq a -> Numbers.BinNums.Z -> a.

Parameter infix_eqeq:
  forall {a:Type} {a_WT:WhyType a}, seq a -> seq a -> Prop.

Axiom infix_eqeq'spec'0 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:seq a) (s2:seq a),
  infix_eqeq s1 s2 <->
  ((length s1) = (length s2)) /\
  (forall (i:Numbers.BinNums.Z), (0%Z <= i)%Z /\ (i < (length s1))%Z ->
   ((get s1 i) = (get s2 i))).

Axiom infix_eqeq'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:seq a) (s2:seq a), infix_eqeq s1 s2 -> (s1 = s2).

Parameter create:
  forall {a:Type} {a_WT:WhyType a}, Numbers.BinNums.Z ->
  (Numbers.BinNums.Z -> a) -> seq a.

Axiom create'spec'0 :
  forall {a:Type} {a_WT:WhyType a},
  forall (len:Numbers.BinNums.Z) (f:Numbers.BinNums.Z -> a),
  (0%Z <= len)%Z -> ((length (create len f)) = len).

Axiom create'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (len:Numbers.BinNums.Z) (f:Numbers.BinNums.Z -> a),
  (0%Z <= len)%Z -> forall (i:Numbers.BinNums.Z),
  (0%Z <= i)%Z /\ (i < len)%Z -> ((get (create len f) i) = (f i)).

Parameter empty: forall {a:Type} {a_WT:WhyType a}, seq a.

Axiom empty'def :
  forall {a:Type} {a_WT:WhyType a}, ((length (empty : seq a)) = 0%Z).

Parameter set:
  forall {a:Type} {a_WT:WhyType a}, seq a -> Numbers.BinNums.Z -> a -> seq a.

Parameter result:
  forall {a:Type} {a_WT:WhyType a}, seq a -> Numbers.BinNums.Z -> a ->
  Numbers.BinNums.Z -> a.

Axiom result'def :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (i:Numbers.BinNums.Z) (v:a) (j:Numbers.BinNums.Z),
  ((j = i) -> ((result s i v j) = v)) /\
  (~ (j = i) -> ((result s i v j) = (get s j))).

Axiom set'def :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (i:Numbers.BinNums.Z) (v:a),
  (0%Z <= i)%Z /\ (i < (length s))%Z ->
  ((set s i v) = (create (length s) (result s i v))).

Axiom set'spec'1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (i:Numbers.BinNums.Z) (v:a),
  (0%Z <= i)%Z /\ (i < (length s))%Z -> ((length (set s i v)) = (length s)).

Axiom set'spec'0 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (i:Numbers.BinNums.Z) (v:a),
  (0%Z <= i)%Z /\ (i < (length s))%Z -> ((get (set s i v) i) = v).

Axiom set'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (i:Numbers.BinNums.Z) (v:a),
  (0%Z <= i)%Z /\ (i < (length s))%Z -> forall (j:Numbers.BinNums.Z),
  ((0%Z <= j)%Z /\ (j < (length s))%Z) /\ ~ (j = i) ->
  ((get (set s i v) j) = (get s j)).

Parameter mixfix_lblsmnrb:
  forall {a:Type} {a_WT:WhyType a}, seq a -> Numbers.BinNums.Z -> a -> seq a.

Axiom mixfix_lblsmnrb'def :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (i:Numbers.BinNums.Z) (v:a),
  (0%Z <= i)%Z /\ (i < (length s))%Z ->
  ((mixfix_lblsmnrb s i v) = (set s i v)).

(* Why3 assumption *)
Definition singleton {a:Type} {a_WT:WhyType a} (v:a) : seq a :=
  create 1%Z (fun (us:Numbers.BinNums.Z) => v).

Axiom singleton'spec'0 :
  forall {a:Type} {a_WT:WhyType a},
  forall (v:a), ((length (singleton v)) = 1%Z).

Axiom singleton'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (v:a), ((get (singleton v) 0%Z) = v).

Parameter result1:
  forall {a:Type} {a_WT:WhyType a}, a -> seq a -> Numbers.BinNums.Z -> a.

Axiom result'def1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (s:seq a) (i:Numbers.BinNums.Z),
  ((i = 0%Z) -> ((result1 x s i) = x)) /\
  (~ (i = 0%Z) -> ((result1 x s i) = (get s (i - 1%Z)%Z))).

(* Why3 assumption *)
Definition cons {a:Type} {a_WT:WhyType a} (x:a) (s:seq a) : seq a :=
  create (1%Z + (length s))%Z (result1 x s).

Axiom cons'spec'1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (s:seq a), ((length (cons x s)) = (1%Z + (length s))%Z).

Axiom cons'spec'0 :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (s:seq a), ((get (cons x s) 0%Z) = x).

Axiom cons'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (s:seq a), forall (i:Numbers.BinNums.Z),
  (0%Z < i)%Z /\ (i <= (length s))%Z ->
  ((get (cons x s) i) = (get s (i - 1%Z)%Z)).

Parameter result2:
  forall {a:Type} {a_WT:WhyType a}, seq a -> a -> Numbers.BinNums.Z -> a.

Axiom result'def2 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (x:a) (i:Numbers.BinNums.Z),
  ((i = (length s)) -> ((result2 s x i) = x)) /\
  (~ (i = (length s)) -> ((result2 s x i) = (get s i))).

(* Why3 assumption *)
Definition snoc {a:Type} {a_WT:WhyType a} (s:seq a) (x:a) : seq a :=
  create (1%Z + (length s))%Z (result2 s x).

Axiom snoc'spec'1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (x:a), ((length (snoc s x)) = (1%Z + (length s))%Z).

Axiom snoc'spec'0 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (x:a), ((get (snoc s x) (length s)) = x).

Axiom snoc'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (x:a), forall (i:Numbers.BinNums.Z),
  (0%Z <= i)%Z /\ (i < (length s))%Z -> ((get (snoc s x) i) = (get s i)).

Parameter mixfix_lbdtdtrb:
  forall {a:Type} {a_WT:WhyType a}, seq a -> Numbers.BinNums.Z ->
  Numbers.BinNums.Z -> seq a.

Axiom mixfix_lbdtdtrb'def :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (i:Numbers.BinNums.Z) (j:Numbers.BinNums.Z),
  (0%Z <= i)%Z /\ (i <= j)%Z /\ (j <= (length s))%Z ->
  ((mixfix_lbdtdtrb s i j) =
   (create (j - i)%Z (fun (k:Numbers.BinNums.Z) => get s (i + k)%Z))).

Axiom mixfix_lbdtdtrb'spec'0 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (i:Numbers.BinNums.Z) (j:Numbers.BinNums.Z),
  (0%Z <= i)%Z /\ (i <= j)%Z /\ (j <= (length s))%Z ->
  ((length (mixfix_lbdtdtrb s i j)) = (j - i)%Z).

Axiom mixfix_lbdtdtrb'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (i:Numbers.BinNums.Z) (j:Numbers.BinNums.Z),
  (0%Z <= i)%Z /\ (i <= j)%Z /\ (j <= (length s))%Z ->
  forall (k:Numbers.BinNums.Z), (0%Z <= k)%Z /\ (k < (j - i)%Z)%Z ->
  ((get (mixfix_lbdtdtrb s i j) k) = (get s (i + k)%Z)).

Parameter mixfix_lb_dtdtrb:
  forall {a:Type} {a_WT:WhyType a}, seq a -> Numbers.BinNums.Z -> seq a.

Axiom mixfix_lb_dtdtrb'def :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (i:Numbers.BinNums.Z),
  (0%Z <= i)%Z /\ (i <= (length s))%Z ->
  ((mixfix_lb_dtdtrb s i) = (mixfix_lbdtdtrb s i (length s))).

Parameter mixfix_lbdtdt_rb:
  forall {a:Type} {a_WT:WhyType a}, seq a -> Numbers.BinNums.Z -> seq a.

Axiom mixfix_lbdtdt_rb'def :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (j:Numbers.BinNums.Z),
  (0%Z <= j)%Z /\ (j <= (length s))%Z ->
  ((mixfix_lbdtdt_rb s j) = (mixfix_lbdtdtrb s 0%Z j)).

Parameter result3:
  forall {a:Type} {a_WT:WhyType a}, seq a -> seq a -> Numbers.BinNums.Z ->
  Numbers.BinNums.Z -> a.

Axiom result'def3 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:seq a) (s2:seq a) (l:Numbers.BinNums.Z) (i:Numbers.BinNums.Z),
  ((i < l)%Z -> ((result3 s1 s2 l i) = (get s1 i))) /\
  (~ (i < l)%Z -> ((result3 s1 s2 l i) = (get s2 (i - l)%Z))).

(* Why3 assumption *)
Definition infix_plpl {a:Type} {a_WT:WhyType a} (s1:seq a) (s2:seq a) : seq a :=
  let l := length s1 in create (l + (length s2))%Z (result3 s1 s2 l).

Axiom infix_plpl'spec'1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:seq a) (s2:seq a),
  ((length (infix_plpl s1 s2)) = ((length s1) + (length s2))%Z).

Axiom infix_plpl'spec'0 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:seq a) (s2:seq a), forall (i:Numbers.BinNums.Z),
  (0%Z <= i)%Z /\ (i < (length s1))%Z ->
  ((get (infix_plpl s1 s2) i) = (get s1 i)).

Axiom infix_plpl'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:seq a) (s2:seq a), forall (i:Numbers.BinNums.Z),
  ((length s1) <= i)%Z /\ (i < (length (infix_plpl s1 s2)))%Z ->
  ((get (infix_plpl s1 s2) i) = (get s2 (i - (length s1))%Z)).

(* Why3 assumption *)
Inductive t_unionfindmodel :=
  | C_UnionFindModel : seq uint64 -> t_unionfindmodel.
Axiom t_unionfindmodel_WhyType : WhyType t_unionfindmodel.
Existing Instance t_unionfindmodel_WhyType.

(* Why3 assumption *)
Definition unionfindmodel_parent (self:t_unionfindmodel) : seq uint64 :=
  match self with
  | C_UnionFindModel a => a
  end.

(* Why3 assumption *)
Inductive borrowed
  (a:Type) :=
  | borrowed'mk : a -> a -> Numbers.BinNums.Z -> borrowed a.
Axiom borrowed_WhyType : forall (a:Type) {a_WT:WhyType a},
  WhyType (borrowed a).
Existing Instance borrowed_WhyType.
Arguments borrowed'mk {a}.

(* Why3 assumption *)
Definition current {a:Type} {a_WT:WhyType a} (v:borrowed a) : a :=
  match v with
  | borrowed'mk x x1 x2 => x
  end.

(* Why3 assumption *)
Definition final {a:Type} {a_WT:WhyType a} (v:borrowed a) : a :=
  match v with
  | borrowed'mk x x1 x2 => x1
  end.

(* Why3 assumption *)
Definition id {a:Type} {a_WT:WhyType a} (v:borrowed a) : Numbers.BinNums.Z :=
  match v with
  | borrowed'mk x x1 x2 => x2
  end.

Parameter inherit_id:
  Numbers.BinNums.Z -> Numbers.BinNums.Z -> Numbers.BinNums.Z.

(* Why3 assumption *)
Definition parent0 (self:t_unionfindmodel) (i:Numbers.BinNums.Z) :
    Numbers.BinNums.Z :=
  uint64'int (get (unionfindmodel_parent self) i).

Parameter reach0:
  t_unionfindmodel -> Numbers.BinNums.Z -> Numbers.BinNums.Z ->
  Numbers.BinNums.Z -> Prop.

Axiom reach0_def :
  forall (self:t_unionfindmodel) (src:Numbers.BinNums.Z)
    (dst:Numbers.BinNums.Z) (len:Numbers.BinNums.Z),
  (reach0 self src dst len ->
   ~ (len < 0%Z)%Z /\
   ((len = 0%Z) -> (src = dst)) /\
   (~ (len = 0%Z) ->
    ~ (src = dst) /\ reach0 self (parent0 self src) dst (len - 1%Z)%Z)) /\
  (~ (len < 0%Z)%Z /\
   ((len = 0%Z) /\ (src = dst) \/
    ~ (len = 0%Z) /\
    ~ (src = dst) /\ reach0 self (parent0 self src) dst (len - 1%Z)%Z) ->
   reach0 self src dst len).

Axiom lemma_reach_nonneg0_spec :
  forall (self:t_unionfindmodel), forall (len:Numbers.BinNums.Z),
  forall (dst:Numbers.BinNums.Z), forall (src:Numbers.BinNums.Z),
  reach0 self src dst len -> (0%Z <= len)%Z.

Axiom lemma_reach_iff0_spec :
  forall (self:t_unionfindmodel), forall (len:Numbers.BinNums.Z),
  forall (dst:Numbers.BinNums.Z), forall (src:Numbers.BinNums.Z),
  reach0 self src dst len <->
  (src = dst) /\ (len = 0%Z) \/
  ~ (src = dst) /\
  (0%Z < len)%Z /\ reach0 self (parent0 self src) dst (len - 1%Z)%Z.

Axiom lemma_reach_intro0_spec :
  forall (self:t_unionfindmodel),
  (forall (src:Numbers.BinNums.Z), reach0 self src src 0%Z) /\
  (forall (len:Numbers.BinNums.Z), forall (dst:Numbers.BinNums.Z),
   forall (src:Numbers.BinNums.Z), ~ (src = dst) ->
   reach0 self (parent0 self src) dst len ->
   reach0 self src dst (len + 1%Z)%Z).

(* Why3 assumption *)
Definition in_range0 (self:t_unionfindmodel) (i:Numbers.BinNums.Z) : Prop :=
  (0%Z <= i)%Z /\ (i < (length (unionfindmodel_parent self)))%Z.

(* Why3 assumption *)
Definition is_root0 (self:t_unionfindmodel) (i:Numbers.BinNums.Z) : Prop :=
  in_range0 self i /\ ((parent0 self i) = i).

(* Why3 assumption *)
Definition belong0 (self:t_unionfindmodel) (i:Numbers.BinNums.Z)
    (root:Numbers.BinNums.Z) : Prop :=
  is_root0 self root /\
  (exists len:Numbers.BinNums.Z, reach0 self i root len).

(* Why3 assumption *)
Definition invariant_belong0 (self:t_unionfindmodel) : Prop :=
  forall (i:Numbers.BinNums.Z), in_range0 self i ->
  exists root:Numbers.BinNums.Z, belong0 self i root.

(* Why3 assumption *)
Definition invariant_range0 (self:t_unionfindmodel) : Prop :=
  forall (i:Numbers.BinNums.Z), in_range0 self i ->
  in_range0 self (parent0 self i).

(* Why3 assumption *)
Definition invariant0 (self:t_unionfindmodel) : Prop :=
  invariant_range0 self /\ invariant_belong0 self.

Parameter self: t_unionfindmodel.

Parameter lemma_reachable_trans: t_unionfindmodel -> Init.Datatypes.unit.

(* Why3 goal *)
Theorem vc_lemma_reachable_trans :
  invariant0 self ->
  (forall (src:Numbers.BinNums.Z), reach0 self src src 0%Z) /\
  (forall (len:Numbers.BinNums.Z), forall (dst:Numbers.BinNums.Z),
   forall (src:Numbers.BinNums.Z), ~ (src = dst) ->
   reach0 self (parent0 self src) dst len ->
   reach0 self src dst (len + 1%Z)%Z) ->
  (forall (len:Numbers.BinNums.Z), forall (dst:Numbers.BinNums.Z),
   forall (src:Numbers.BinNums.Z),
   reach0 self src dst len <->
   (src = dst) /\ (len = 0%Z) \/
   ~ (src = dst) /\
   (0%Z < len)%Z /\ reach0 self (parent0 self src) dst (len - 1%Z)%Z) ->
  (forall (len:Numbers.BinNums.Z), forall (dst:Numbers.BinNums.Z),
   forall (src:Numbers.BinNums.Z), reach0 self src dst len -> (0%Z <= len)%Z) ->
  forall (k:Numbers.BinNums.Z), forall (j:Numbers.BinNums.Z),
  forall (i:Numbers.BinNums.Z),
  (exists n:Numbers.BinNums.Z, reach0 self i j n) ->
  (exists n:Numbers.BinNums.Z, reach0 self j k n) ->
  exists n:Numbers.BinNums.Z, reach0 self i k n.
Proof.
  Open Scope Z_scope.
  intros _ _ _ _.
  intros k j i [a Hij] [b Hjk].
  revert i Hij .
  induction a as [a IH] using (well_founded_induction (Z.lt_wf 0)).
  intros i Hij.
  rewrite lemma_reach_iff0_spec in Hij.
  destruct Hij as [Hij | Hij].
  - intuition. subst. firstorder.
  - destruct (Z.eq_dec i k).
    + subst. exists 0. 
      apply lemma_reach_intro0_spec.
    + destruct Hij as (Hne  & Hpos & Hreach).
      apply IH in Hreach; auto with zarith.
      destruct Hreach as [a' Hreach].
      exists (a' + 1).
      apply lemma_reach_intro0_spec; auto.
Qed.
